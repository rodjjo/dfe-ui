/*
 * Copyright (C) 2023 by Rodrigo Antonio de Araujo
 */
#include <string>
#include <map>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <SFML/Graphics/Texture.hpp>
#include <SFML/Graphics/Image.hpp>
#include "simple-ui/icons.h"

#pragma GCC diagnostic push
// there is no problem, i dont use it as a char *, i do as const char*
// i'd rather not modify .xpm files because it's generated by gimp and i keep it as it is.
#pragma GCC diagnostic ignored "-Wwrite-strings"

#include "xpm/24x24/new.xpm"
#include "xpm/24x24/door.xpm"
#include "xpm/24x24/folder.xpm"
#include "xpm/24x24/wallet.xpm"
#include "xpm/24x24/pinion.xpm"
#include "xpm/24x24/exit.xpm"
#include "xpm/24x24/component.xpm"
#include "xpm/24x24/close.xpm"
#include "xpm/24x24/computer.xpm"
#include "xpm/24x24/remove.xpm"
#include "xpm/24x24/erase.xpm"
#include "xpm/24x24/copy.xpm"
#include "xpm/24x24/picture.xpm"
#include "xpm/24x24/ok.xpm"
#include "xpm/24x24/abort.xpm"
#include "xpm/24x24/bee.xpm"
#include "xpm/24x24/magic_wand.xpm"
#include "xpm/24x24/back.xpm"
#include "xpm/24x24/forward.xpm"
#include "xpm/24x24/heart.xpm"
#include "xpm/24x24/medium_rating.xpm"
#include "xpm/24x24/new_document.xpm"
#include "xpm/24x24/flash_drive.xpm"
#include "xpm/24x24/green_pin.xpm"
#include "xpm/24x24_cursors/arrow_cursor.xpm"

#pragma GCC diagnostic pop

namespace dfe_ui {

typedef struct {
    uint32_t w;
    uint32_t h;
    uint32_t colors;
} xpm_header_t;

typedef struct {
    xpm_header_t header;
    size_t stride;
    size_t memsize;
    std::shared_ptr<uint8_t> data;
} xpm_data_t;

auto load_db() {
    std::map<icon_type_t, const char * const*> xpm_db = {
        { img_24x24_exit, xpm_exit },
        { img_24x24_new, xpm_new },
        { img_24x24_new_document, xpm_new_document },
        { img_24x24_open_layer, xpm_component},
        { img_24x24_close, xpm_close},
        { img_24x24_open, xpm_door },
        { img_24x24_folder, xpm_folder },
        { img_24x24_wallet, xpm_wallet },
        { img_24x24_flash_drive, xpm_flash_drive },
        { img_24x24_pinion, xpm_pinion },
        { img_24x24_green_pin, xpm_green_pin },
        { img_24x24_settings, xpm_computer },
        { img_24x24_bee, xpm_bee },
        { img_24x24_remove, xpm_remove },
        { img_24x24_erase, xpm_erase},
        { img_24x24_copy, xpm_copy },
        { img_24x24_picture, xpm_picture },
        { img_24x24_ok, xpm_ok },
        { img_24x24_abort, xpm_abort },
        { img_24x24_magic_wand, xpm_magic_wand},
        { img_24x24_back, xpm_back },
        { img_24x24_forward, xpm_forward },
        { img_24x24_heart, xpm_heart },
        { img_24x24_medium_rating, xpm_medium_rating },
        { cur_24x24_arrow, arrow_cursor},
    };
    return xpm_db;
}

xpm_header_t xpm_size(const char * const* data) {
    xpm_header_t header;
    header.colors = 0;
    header.w = 0;
    header.h = 0;
    const char *p = data[0];
    uint32_t x, y, pal;
    if (sscanf(p, "%u %u %u 2", &x, &y, &pal) == 3) {
        header.colors = pal;
        header.w = x;
        header.h = y;
        return header;
    }
    return header;
};

typedef struct {
    union {
        uint32_t color;
        u_int8_t c[4];
    };
} color_conversion_t;

uint32_t xpm_parse_color(const std::string & color_value) {
    if (color_value == "None") {
        return 0;  
    }
    auto color = std::string("0x00") + color_value.substr(1);
    uint32_t val = 0;
    if (sscanf(color.c_str(), "%x", &val) != 1) {
        puts("a failure happened while parsing color!");
    };
    color_conversion_t c;
    c.color = val;
    val = c.c[0] << 16 | c.c[1] << 8 | c.c[2] | 0xFF000000;
    return val;
}

xpm_data_t xpm_parse_image(const char * const* data) {
    xpm_data_t result;
    result.header = xpm_size(data);
    result.stride = 4 * result.header.w;
    result.memsize = result.stride * result.header.h;
    result.data.reset((uint8_t *)malloc(result.memsize));
    memset(result.data.get(), 0, result.memsize);

    std::map<std::string, uint32_t> colors;
    int color_size = 0;
    for (int i = 1; i <= result.header.colors; i++) {
        const char *color_row = data[i];
        const char *p = color_row;
        std::string color_name;
        std::string color_value;
        while (*p != '\0' && *p != '\t') {
            color_name.push_back(*p);
            p++;
        }
        while (*p != '\0' && *p != 'c') {
            p++;
        }
        while (*p == 'c' || *p == ' ') {
            p++;
        }
        colors[color_name] = xpm_parse_color(p);
        if (color_size == 0) {
            color_size = color_name.size();
        }
    }
    uint32_t *bitmap = (uint32_t *)result.data.get();
    for (uint32_t y = 0; y < result.header.h; y++) {
        const char *p = data[result.header.colors + 1 + y]; // skip the header
        for (uint32_t x = 0; x < result.header.w; x++) {
            std::string color_name;    
            while (color_name.size() < color_size) {
                color_name.push_back(*p);
                if (*p == '\0') {
                    puts("Error parsing XPM data");
                }
                p++;
            }
            *bitmap = colors[color_name];
            bitmap++;
            
        }
    }
    return result;
}

uint32_t xpm_optimal_width(std::map<icon_type_t, const char * const*>& db) {
    uint64_t area = 0;
    for (auto item: db) {
        auto info = xpm_size(db[item.first]);
        area += info.w * info.h;
    }
    return (uint32_t)sqrt((double)area);
}

typedef struct {
    sf::Texture texture;
} texture_holder_t;


class IconTexture: public IconTextureBase {
   public:
    IconTexture();
    void *sfml_texture() override;
    std::pair<int, int> get_coords(icon_type_t xpm_id);
    std::pair<int, int> get_size(icon_type_t xpm_id);
  private:
    size_t m_memosize = 0;
    std::shared_ptr<sf::Texture> m_texture;
    std::map<icon_type_t, std::pair<uint32_t, uint32_t> > m_coordinates;
    std::map<icon_type_t, std::pair<uint32_t, uint32_t> > m_sizes;
};

IconTexture::IconTexture() {
    std::shared_ptr<uint8_t> data;
    auto db = load_db();

    // generate a square format image
    uint32_t img_width = xpm_optimal_width(db);
    uint32_t pack_pixels = 0;
    if (img_width % 4 != 0) {
        pack_pixels = (4 - img_width % 4); 
        img_width += pack_pixels;
    }

    uint32_t width = 0;
    uint32_t height = 0;

    for (int pass = 1; pass < 3; pass++) {
        uint32_t current_x = 0;
        uint32_t current_y = 0;
        uint32_t current_h = 0;
        for (auto item: db) {
            auto info = xpm_size(item.second);
            if (current_h < info.h) {
                current_h = info.h;
            }
            if (pass == 2) {
                m_coordinates[item.first] = std::make_pair(current_x, current_y);
                m_sizes[item.first] = std::make_pair(info.w, info.h);
                auto xpm_image = xpm_parse_image(item.second);
                uint8_t *source = xpm_image.data.get();
                size_t target_stride = (4 * img_width);
                uint8_t *target_buffer = data.get();
                target_buffer += (current_y * target_stride) + current_x * 4;
                for (uint32_t y = 0;  y < xpm_image.header.h; y++) {
                    memcpy(target_buffer, source, xpm_image.stride);
                    source += xpm_image.stride;
                    target_buffer += target_stride;
                }
            }
            if (current_x + info.w >= (img_width - pack_pixels)) {
                current_y +=  current_h;
                current_h = 0;
                current_x = 0;
            } else {
                current_x += info.w;
            }
        }
        current_y += current_h;
        if (pass == 1) {
            width = img_width;
            height = current_y;
            m_memosize = 4 * width * height;
            data.reset((uint8_t *)malloc(m_memosize));
            memset(data.get(), 0, m_memosize);
        }
    }
    sf::Texture texture({width, height});
    m_texture.reset(new sf::Texture(std::move(texture)));
    m_texture->update((uint8_t *) data.get());
    auto i = m_texture->copyToImage();
}

void *IconTexture::sfml_texture() {
    return m_texture.get();
}

std::pair<int, int> IconTexture::get_coords(icon_type_t xpm_id) {
    auto it = m_coordinates.find(xpm_id);
    if (it != m_coordinates.end()) {
        return it->second;
    }
    return std::make_pair(0, 0);
}

std::pair<int, int> IconTexture::get_size(icon_type_t xpm_id) {
    auto it = m_sizes.find(xpm_id);
    if (it != m_sizes.end()) {
        return it->second;
    }
    return std::make_pair(0, 0);
}

namespace {
    std::shared_ptr<IconTextureBase> textures;
}

IconTextureBase* load_icons_texture() {
    if (!textures) {
        textures = std::make_shared<IconTexture>();
    }
    return textures.get();
}

void unload_icons_texture() {
    textures.reset();
}


}  // namespace vcutter
